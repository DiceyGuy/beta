<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Scanner Pro v3.0 - Multi-Mode + AI Deckbuilder</title>
    <script src="https://js.stripe.com/v3/"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
            color: white; min-height: 100vh; overflow-x: hidden;
        }
        
        .loading-screen {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(135deg, #0a0a0a, #1a1a2e, #16213e);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 10000; opacity: 1; transition: opacity 1s ease-out;
        }
        .loading-screen.fade-out { opacity: 0; }
        
        .welcome-content { text-align: center; animation: welcomeSlide 2s ease-out; }
        .welcome-title {
            font-size: 3.5em; color: #4a90e2; margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(74, 144, 226, 0.5);
        }
        .welcome-subtitle { font-size: 1.3em; color: #888; margin-bottom: 30px; }
        .loading-spinner {
            width: 50px; height: 50px; border: 5px solid #333;
            border-top: 5px solid #4a90e2; border-radius: 50%; 
            animation: spin 1s linear infinite; margin: 20px auto;
        }
        
        @keyframes welcomeSlide {
            0% { transform: translateY(50px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .app-container { 
            opacity: 0; transition: opacity 1s ease-in; padding: 20px;
            transform: translateY(20px);
        }
        .app-container.loaded { opacity: 1; transform: translateY(0); }
        
        .container { max-width: 1400px; margin: 0 auto; }
        .header { text-align: center; margin-bottom: 30px; }
        .header h1 { color: #4a90e2; font-size: 2.5em; margin-bottom: 10px; }
        .header p { color: #888; font-size: 1.1em; }
        
        .version-badge {
            background: linear-gradient(45deg, #ff6b35, #f44336);
            color: white; padding: 5px 15px; border-radius: 20px;
            font-size: 12px; font-weight: bold; margin-left: 10px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .alpha-input {
            position: fixed; top: 20px; right: 20px; z-index: 1000;
            background: rgba(255, 255, 255, 0.1); border: 1px solid #4a90e2;
            border-radius: 8px; padding: 8px 12px; color: white;
            font-size: 12px; width: 200px;
        }
        
        .usage-tracker {
            background: #2a2a2a; border: 1px solid #4a90e2; border-radius: 12px;
            padding: 15px; margin-bottom: 20px;
        }
        .usage-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .usage-stats { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .usage-bar { background: #1a1a1a; height: 6px; border-radius: 3px; overflow: hidden; }
        .usage-fill { height: 100%; background: #4a90e2; transition: width 0.3s ease; }
        
        .main-content { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; }
        .section {
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px; padding: 20px; position: relative;
        }
        .section h3 { color: #4a90e2; margin-bottom: 15px; font-size: 1.3em; }
        
        .video-container {
            position: relative; background: #000; border-radius: 8px; overflow: hidden;
            aspect-ratio: 16/9; margin-bottom: 15px;
        }
        #video { width: 100%; height: 100%; object-fit: cover; }
        .camera-status {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; color: white; background: rgba(0,0,0,0.8);
            padding: 20px; border-radius: 8px;
        }
        
        /* SCANNING MODE SELECTOR */
        .scan-mode-selector {
            background: rgba(74, 144, 226, 0.1); border: 1px solid rgba(74, 144, 226, 0.3);
            border-radius: 8px; padding: 15px; margin-bottom: 15px;
        }
        
        .scan-mode-selector h4 {
            color: #4a90e2; margin-bottom: 10px; font-size: 14px;
            text-transform: uppercase; font-weight: bold;
        }
        
        .scan-modes {
            display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;
        }
        
        .scan-mode {
            background: #2a2a2a; border: 2px solid #333; border-radius: 6px;
            padding: 8px; cursor: pointer; transition: all 0.3s ease;
            text-align: center; font-size: 11px;
        }
        
        .scan-mode.active {
            border-color: #4a90e2; background: rgba(74, 144, 226, 0.2);
        }
        
        .scan-mode:hover {
            border-color: #4a90e2;
        }
        
        .mode-icon { font-size: 16px; margin-bottom: 4px; }
        .mode-name { font-weight: bold; color: #4a90e2; margin-bottom: 2px; }
        .mode-desc { color: #888; font-size: 10px; }
        
        .controls { display: flex; gap: 10px; }
        .btn {
            padding: 12px 20px; border: none; border-radius: 8px; cursor: pointer;
            font-weight: bold; font-size: 14px; transition: all 0.3s ease;
            position: relative; overflow: hidden;
        }
        .btn-primary { background: #4a90e2; color: white; flex: 1; }
        .btn-primary:hover { background: #357abd; transform: translateY(-2px); }
        .btn-secondary { background: #28a745; color: white; padding: 12px 16px; }
        .btn:disabled { background: #666; cursor: not-allowed; }
        
        .result-card {
            background: #2a2a2a; border: 1px solid #4a90e2; border-radius: 12px;
            padding: 20px; text-align: center; position: relative;
            animation: resultSlideIn 0.6s ease-out;
        }
        .result-card h4 { color: #4a90e2; font-size: 1.4em; margin-bottom: 10px; }
        .confidence { color: #888; margin-bottom: 15px; }
        .placeholder {
            background: #2a2a2a; border-radius: 8px; padding: 40px;
            text-align: center; color: #888;
        }
        
        /* EDITION SELECTOR */
        .edition-selector {
            background: rgba(255, 193, 7, 0.1); border: 1px solid #ffc107;
            border-radius: 8px; padding: 15px; margin: 15px 0;
        }
        
        .edition-options {
            display: grid; grid-template-columns: 1fr; gap: 8px; max-height: 150px; overflow-y: auto;
        }
        
        .edition-option {
            background: #2a2a2a; border: 1px solid #333; border-radius: 6px;
            padding: 10px; cursor: pointer; transition: all 0.3s ease;
            text-align: left;
        }
        
        .edition-option:hover { border-color: #ffc107; }
        .edition-option.selected { border-color: #ffc107; background: rgba(255, 193, 7, 0.2); }
        
        .edition-name { font-weight: bold; color: #ffc107; font-size: 14px; }
        .edition-details { color: #888; font-size: 12px; margin-top: 4px; }
        
        /* AI DECKBUILDER SECTION */
        .deckbuilder-section {
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px; padding: 20px;
        }
        
        .format-selector {
            display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap;
        }
        
        .format-tab {
            background: #2a2a2a; border: 1px solid #4a90e2; border-radius: 6px;
            padding: 8px 12px; cursor: pointer; font-size: 12px;
            transition: all 0.3s ease; white-space: nowrap;
        }
        
        .format-tab.active { background: #4a90e2; color: white; }
        .format-tab:hover { background: #3a3a3a; }
        
        .ai-suggestions {
            background: #1a1a1a; border-radius: 8px; padding: 15px;
            min-height: 200px;
        }
        
        .suggestion-card {
            background: #2a2a2a; border-radius: 8px; padding: 12px; margin-bottom: 10px;
            border-left: 4px solid #4a90e2;
        }
        
        .suggestion-title { font-weight: bold; color: #4a90e2; margin-bottom: 5px; }
        .suggestion-desc { color: #ccc; font-size: 13px; margin-bottom: 8px; }
        .suggestion-cards { color: #888; font-size: 12px; }
        
        @keyframes resultSlideIn {
            0% { opacity: 0; transform: translateY(30px) scale(0.9); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }

        /* COLLECTION SECTION */
        .binder-section {
            background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px; padding: 20px; margin-top: 20px;
        }
        .binder-tabs {
            display: flex; gap: 10px; overflow-x: auto;
            scrollbar-width: thin; scrollbar-color: #4a90e2 #1a1a1a;
            padding-bottom: 5px;
        }
        .binder-tab {
            background: #2a2a2a; border: 1px solid #4a90e2; border-radius: 8px;
            padding: 10px 15px; cursor: pointer; white-space: nowrap;
            transition: all 0.3s ease; min-width: fit-content; text-align: center;
            font-size: 13px; display: flex; align-items: center; gap: 5px;
        }
        .binder-tab.active { background: #4a90e2; color: white; }
        .binder-tab:hover { background: #3a3a3a; }
        
        .binder-content {
            background: #1a1a1a; border-radius: 8px; padding: 15px; min-height: 200px;
        }
        .binder-stats {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px; margin-bottom: 20px;
        }
        .stat-item {
            background: #2a2a2a; border-radius: 6px; padding: 12px; text-align: center;
        }
        .stat-number { font-size: 24px; font-weight: bold; color: #4a90e2; }
        .stat-label { font-size: 12px; color: #888; }
        
        .card-grid {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px;
        }
        .collection-card {
            background: #2a2a2a; border-radius: 12px; border: 1px solid #333; 
            padding: 15px; transition: all 0.3s ease; position: relative;
            overflow: hidden;
        }
        .collection-card:hover { 
            border-color: #4a90e2; transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(74, 144, 226, 0.2);
        }
        .card-name { 
            font-weight: bold; color: #4a90e2; margin-bottom: 8px; font-size: 16px;
        }
        .card-details { 
            font-size: 12px; color: #888; margin-bottom: 10px;
        }
        .card-price {
            background: #4a90e2; color: white; padding: 4px 8px; border-radius: 6px;
            font-size: 12px; font-weight: bold; display: inline-block;
        }
        
        @media (max-width: 768px) { 
            .main-content { grid-template-columns: 1fr; }
            .scan-modes { grid-template-columns: 1fr; }
            .format-selector { justify-content: center; }
        }
        
        @media (max-width: 1200px) {
            .main-content { grid-template-columns: 1fr 1fr; }
        }
    </style>
</head>
<body>
    <!-- ALPHA TESTING INPUT -->
    <input type="text" id="alphaCode" class="alpha-input" placeholder="🔑 Enter alpha code..." 
           onkeypress="if(event.key==='Enter') checkAlphaCode()">

    <!-- LOADING SCREEN -->
    <div id="loadingScreen" class="loading-screen">
        <div class="welcome-content">
            <div class="welcome-title">🃏 MTG Scanner Pro</div>
            <div class="welcome-subtitle">Multi-Mode Scanning + AI Deckbuilder</div>
            <div style="font-size: 0.9em; color: #ff6b35; margin-top: 5px;">
                Version 3.0 - Fast/Accurate/Manual Modes + Format-Specific Deckbuilding! 🚀
            </div>
            <div class="loading-spinner"></div>
        </div>
    </div>

    <!-- MAIN APP -->
    <div id="mainApp" class="app-container">
        <div class="container">
            <div class="header">
                <h1>🃏 MTG Scanner Pro <span class="version-badge">v3.0 MULTI-MODE</span></h1>
                <p>Multi-Mode Scanning • AI Deckbuilder • Format Intelligence • Real-Time Pricing</p>
            </div>

            <div class="usage-tracker">
                <div class="usage-header">
                    <span style="color: #4a90e2; font-weight: bold;">
                        📊 <span id="usagePeriodLabel">Daily</span> Usage (<span id="userTierDisplay">Free</span>)
                    </span>
                    <button id="upgradeBtn" class="btn" style="background: #4a90e2; color: white; padding: 6px 12px; font-size: 12px; border-radius: 6px;">
                        💎 Upgrade - Starting $4.99
                    </button>
                </div>
                <div class="usage-stats">
                    <span style="font-weight: bold;"><span id="usageCount">0</span> / <span id="usageLimit">20</span> scans</span>
                    <span style="color: #888; font-size: 12px;"><span id="remainingCount">20</span> remaining</span>
                </div>
                <div class="usage-bar">
                    <div id="usageBar" class="usage-fill" style="width: 0%;"></div>
                </div>
            </div>

            <div class="main-content">
                <!-- SCANNING SECTION -->
                <div class="section">
                    <h3>📷 Multi-Mode Scanner</h3>
                    
                    <!-- SCAN MODE SELECTOR -->
                    <div class="scan-mode-selector">
                        <h4>🎯 Scanning Mode</h4>
                        <div class="scan-modes">
                            <div class="scan-mode active" data-mode="fast">
                                <div class="mode-icon">⚡</div>
                                <div class="mode-name">Fast</div>
                                <div class="mode-desc">1-2 sec<br>Latest edition</div>
                            </div>
                            <div class="scan-mode" data-mode="accurate">
                                <div class="mode-icon">🎯</div>
                                <div class="mode-name">Accurate</div>
                                <div class="mode-desc">3-5 sec<br>Exact match</div>
                            </div>
                            <div class="scan-mode" data-mode="manual">
                                <div class="mode-icon">✋</div>
                                <div class="mode-name">Manual</div>
                                <div class="mode-desc">User picks<br>Edition list</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="video-container">
                        <video id="video" autoplay muted playsinline></video>
                        <div id="cameraStatus" class="camera-status">📷 Initializing multi-mode scanner...</div>
                    </div>
                    <div class="controls">
                        <button id="scanBtn" class="btn btn-primary" disabled>⚡ Fast Scan</button>
                        <button id="autoBtn" class="btn btn-secondary">▶️ Auto</button>
                    </div>
                </div>

                <!-- RESULTS SECTION -->
                <div class="section">
                    <h3>🎯 Scan Results</h3>
                    <div id="results">
                        <div class="placeholder">
                            📷 Point camera at MTG card<br>
                            <small style="color: #888;">Choose scanning mode for speed vs accuracy!</small>
                        </div>
                    </div>
                </div>

                <!-- AI DECKBUILDER SECTION -->
                <div class="section deckbuilder-section">
                    <h3>🤖 AI Deckbuilder</h3>
                    
                    <div class="format-selector">
                        <div class="format-tab active" data-format="commander">👑 Commander</div>
                        <div class="format-tab" data-format="standard">🎯 Standard</div>
                        <div class="format-tab" data-format="pioneer">🚀 Pioneer</div>
                        <div class="format-tab" data-format="modern">⚡ Modern</div>
                        <div class="format-tab" data-format="legacy">🏛️ Legacy</div>
                    </div>
                    
                    <div class="ai-suggestions" id="aiSuggestions">
                        <div class="suggestion-card">
                            <div class="suggestion-title">🤖 Select a format to start!</div>
                            <div class="suggestion-desc">AI will analyze your collection and suggest deck improvements based on the current meta.</div>
                            <div class="suggestion-cards">Available formats: Commander, Standard, Pioneer, Modern, Legacy</div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; display: flex; gap: 10px;">
                        <button onclick="buildDeck()" class="btn" style="background: #6f42c1; color: white; flex: 1; padding: 10px; font-size: 13px;">
                            🏗️ Build Deck
                        </button>
                        <button onclick="optimizeDeck()" class="btn" style="background: #fd7e14; color: white; flex: 1; padding: 10px; font-size: 13px;">
                            ⚡ Optimize
                        </button>
                    </div>
                </div>
            </div>

            <!-- DIGITAL COLLECTION SECTION -->
            <div class="binder-section">
                <h3 style="color: #4a90e2; margin-bottom: 20px;">📚 Collection + Deckbuilder</h3>
                
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <div class="binder-tabs" style="flex: 1;">
                        <div class="binder-tab active" data-binder="main">📂 Main</div>
                        <div class="binder-tab" data-binder="premium">💎 Premium</div>
                        <div class="binder-tab" data-binder="commander">👑 Commander</div>
                        <div class="binder-tab" data-binder="standard">🎯 Standard</div>
                        <div class="binder-tab" data-binder="modern">⚡ Modern</div>
                        <div class="binder-tab" data-binder="decks">🏗️ Decks</div>
                        <div class="binder-tab" data-binder="wishlist">⭐ Wishlist</div>
                    </div>
                </div>
                
                <div class="binder-content">
                    <div class="binder-stats">
                        <div class="stat-item">
                            <div class="stat-number" id="totalCards">0</div>
                            <div class="stat-label">Total Cards</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="uniqueCards">0</div>
                            <div class="stat-label">Unique Cards</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="totalValue">$0.00</div>
                            <div class="stat-label">Collection Value</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-number" id="deckCount">0</div>
                            <div class="stat-label">Complete Decks</div>
                        </div>
                    </div>
                    
                    <div id="binderCards" class="card-grid">
                        <div style="text-align: center; color: #888; padding: 40px;">
                            No cards in this collection yet. Start scanning to build decks with AI assistance!
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 🚀 MTG SCANNER PRO v3.0 - MULTI-MODE + AI DECKBUILDER
        console.log("🚀 MTG Scanner Pro v3.0 Loading (Multi-Mode + AI Deckbuilder)...");

        // ALPHA TESTING SYSTEM
        const ALPHA_CODES = {
            'ALPHA2024MTG': { 
                tier: 'pro', 
                expires: '2024-02-14', 
                email: 'alpha@tester.com',
                features: ['unlimited_scans', 'all_modes', 'ai_deckbuilder']
            },
            'BETA2024BUILDER': { 
                tier: 'family', 
                expires: '2024-02-14', 
                email: 'beta@tester.com',
                features: ['unlimited_scans', 'ai_deckbuilder', 'format_analysis']
            },
            'DEVTEST2024': {
                tier: 'store',
                expires: '2024-03-14',
                email: 'dev@test.com',
                features: ['unlimited_scans', 'all_modes', 'all_features']
            }
        };

        function checkAlphaCode() {
            const code = document.getElementById('alphaCode').value.trim().toUpperCase();
            const alphaData = ALPHA_CODES[code];
            
            if (alphaData) {
                const now = new Date();
                const expires = new Date(alphaData.expires);
                
                if (now <= expires) {
                    localStorage.setItem('mtg_user_tier', 'premium');
                    localStorage.setItem('mtg_plan_type', alphaData.tier);
                    localStorage.setItem('mtg_alpha_code', code);
                    localStorage.setItem('mtg_alpha_expires', alphaData.expires);
                    
                    userTier = 'premium';
                    userPlan = alphaData.tier;
                    
                    document.getElementById('alphaCode').style.background = '#28a745';
                    document.getElementById('alphaCode').value = '✅ Alpha Access Activated!';
                    document.getElementById('alphaCode').disabled = true;
                    
                    updateUsageDisplay();
                    
                    setTimeout(() => {
                        alert(`🎉 Alpha Access Activated!\n\nPlan: ${alphaData.tier.toUpperCase()}\nFeatures: Multi-mode scanning + AI Deckbuilder\nExpires: ${alphaData.expires}\n\nYou now have unlimited scans and all features!`);
                    }, 500);
                    
                    console.log('✅ Alpha access granted:', alphaData);
                } else {
                    alert('❌ Alpha code expired!');
                    document.getElementById('alphaCode').style.background = '#dc3545';
                }
            } else {
                alert('❌ Invalid alpha code!');
                document.getElementById('alphaCode').style.background = '#dc3545';
                setTimeout(() => {
                    document.getElementById('alphaCode').style.background = 'rgba(255, 255, 255, 0.1)';
                }, 2000);
            }
        }

        // ENHANCED MTG SERVICE WITH MULTI-MODE SCANNING
        class MultiModeMTGService {
            constructor() {
                this.apiKey = 'AIzaSyBtqyUy1X3BdNtUAW88QZWbtqI39MbUDdk';
                this.geminiUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent';
                this.scryfallUrl = 'https://api.scryfall.com';
                this.lastApiCall = 0;
                this.minInterval = 3000;
                this.errors = 0;
                this.scanMode = 'fast'; // fast, accurate, manual
            }

            setScanMode(mode) {
                this.scanMode = mode;
                console.log(`🎯 Scan mode set to: ${mode}`);
            }

            async scanCard(video) {
                try {
                    const now = Date.now();
                    if (now - this.lastApiCall < this.minInterval) {
                        await new Promise(r => setTimeout(r, this.minInterval - (now - this.lastApiCall)));
                    }
                    this.lastApiCall = Date.now();

                    const imageData = this.captureFrame(video);
                    
                    let result;
                    switch(this.scanMode) {
                        case 'fast':
                            result = await this.fastScan(imageData);
                            break;
                        case 'accurate':
                            result = await this.accurateScan(imageData);
                            break;
                        case 'manual':
                            result = await this.manualScan(imageData);
                            break;
                        default:
                            result = await this.fastScan(imageData);
                    }
                    
                    if (result.hasCard) {
                        result.cardData = await this.getCardData(result);
                    }
                    
                    this.errors = 0;
                    return result;
                } catch (error) {
                    console.error("🚨 Multi-mode AI error:", error);
                    this.errors++;
                    
                    if (this.errors > 3) {
                        console.warn('⚠️ Too many errors, using fallback');
                        return this.getFallback();
                    }
                    
                    return {
                        hasCard: false,
                        message: "Multi-mode scanner temporarily unavailable - please try again",
                        error: true
                    };
                }
            }

            async fastScan(imageData) {
                console.log("⚡ Fast scan mode - Name only, latest edition");
                
                const fastPrompt = `
Quickly identify this Magic: The Gathering card. Focus on speed over accuracy.

Just extract:
CARD_NAME: [exact card name]
CONFIDENCE: [80-99]

If you see an MTG card, respond: CARD_NAME: Lightning Bolt | CONFIDENCE: 95
If no MTG card, respond: NO_MTG_CARD
`;

                const result = await this.callGemini(imageData, fastPrompt);
                if (result.hasCard) {
                    result.scanMode = 'fast';
                    result.editionNote = 'Latest edition used for speed';
                }
                return result;
            }

            async accurateScan(imageData) {
                console.log("🎯 Accurate scan mode - Full metadata extraction");
                
                const accuratePrompt = `
Carefully analyze this Magic: The Gathering card for maximum accuracy.

Extract ALL visible metadata:
1. CARD_NAME: [exact card name from title]
2. SET_CODE: [3-4 letter code in bottom left corner]
3. COLLECTOR_NUM: [number in bottom left]
4. RARITY: [set symbol color: black=common, silver=uncommon, gold=rare, orange=mythic]
5. ARTIST: [artist name in bottom right]
6. CONFIDENCE: [80-99]

Take your time to read the small text accurately.

Format: CARD_NAME: Lightning Bolt | SET_CODE: M21 | COLLECTOR_NUM: 160 | RARITY: common | ARTIST: Artist Name | CONFIDENCE: 95

If no MTG card, respond: NO_MTG_CARD
`;

                const result = await this.callGemini(imageData, accuratePrompt);
                if (result.hasCard) {
                    result.scanMode = 'accurate';
                    result.editionNote = 'Exact edition detected';
                }
                return result;
            }

            async manualScan(imageData) {
                console.log("✋ Manual scan mode - Get name, let user pick edition");
                
                const manualPrompt = `
Identify this Magic: The Gathering card name for manual edition selection.

Extract:
CARD_NAME: [exact card name]
CONFIDENCE: [80-99]

Format: CARD_NAME: Lightning Bolt | CONFIDENCE: 95
If no MTG card, respond: NO_MTG_CARD
`;

                const result = await this.callGemini(imageData, manualPrompt);
                if (result.hasCard) {
                    result.scanMode = 'manual';
                    result.editionNote = 'Manual edition selection required';
                    result.needsEditionPicker = true;
                }
                return result;
            }

            async getCardData(scanResult) {
                try {
                    console.log(`🔍 Getting card data for ${scanResult.scanMode} scan:`, scanResult);
                    
                    if (scanResult.scanMode === 'accurate' && scanResult.setCode && scanResult.collectorNum) {
                        // Try exact match
                        const exactUrl = `${this.scryfallUrl}/cards/${scanResult.setCode.toLowerCase()}/${scanResult.collectorNum}`;
                        console.log(`🎯 Exact match URL: ${exactUrl}`);
                        
                        const exactResponse = await fetch(exactUrl);
                        if (exactResponse.ok) {
                            const data = await exactResponse.json();
                            console.log('✅ EXACT MATCH FOUND:', data.name);
                            return this.formatCardData(data, 'exact_match');
                        }
                    }
                    
                    if (scanResult.scanMode === 'manual' && scanResult.needsEditionPicker) {
                        // Get all printings for manual selection
                        const printingsUrl = `${this.scryfallUrl}/cards/search?q=!"${scanResult.name}"&unique=prints`;
                        console.log(`📋 Getting all printings: ${printingsUrl}`);
                        
                        const printingsResponse = await fetch(printingsUrl);
                        if (printingsResponse.ok) {
                            const data = await printingsResponse.json();
                            console.log(`📋 Found ${data.data.length} printings`);
                            
                            scanResult.allPrintings = data.data.slice(0, 10); // Limit to 10 most relevant
                            // Return the most recent printing as default
                            return this.formatCardData(data.data[0], 'manual_default');
                        }
                    }
                    
                    // Fallback to fuzzy search (fast mode or failures)
                    const fuzzyUrl = `${this.scryfallUrl}/cards/named?fuzzy=${encodeURIComponent(scanResult.name.trim())}`;
                    console.log(`🔍 Fuzzy search: ${fuzzyUrl}`);
                    
                    const fuzzyResponse = await fetch(fuzzyUrl);
                    if (fuzzyResponse.ok) {
                        const data = await fuzzyResponse.json();
                        console.log('✅ Fuzzy match found:', data.name);
                        return this.formatCardData(data, 'fuzzy_match');
                    }
                    
                    // No data found
                    return {
                        name: scanResult.name,
                        price: 'Price unavailable',
                        set: 'Unknown',
                        scryfallError: true,
                        matchType: 'no_match'
                    };
                    
                } catch (error) {
                    console.error('❌ Card data error:', error);
                    return {
                        name: scanResult.name,
                        price: 'Price unavailable',
                        set: 'Unknown',
                        scryfallError: true,
                        matchType: 'error'
                    };
                }
            }

            formatCardData(data, matchType) {
                let price = null;
                if (data.prices) {
                    price = data.prices.usd || 
                           data.prices.usd_foil || 
                           data.prices.eur || 
                           data.prices.tix || 
                           'Price not available';
                }
                
                return {
                    name: data.name,
                    image: data.image_uris ? data.image_uris.normal : null,
                    price: price,
                    set: data.set_name,
                    setCode: data.set.toUpperCase(),
                    rarity: data.rarity,
                    scryfallId: data.id,
                    scryfallUri: data.scryfall_uri || data.uri,
                    cmc: data.cmc || 0,
                    colors: data.colors || [],
                    type_line: data.type_line || '',
                    collectorNumber: data.collector_number || '',
                    releaseDate: data.released_at || '',
                    artist: data.artist || '',
                    matchType: matchType
                };
            }

            async callGemini(imageData, prompt) {
                const body = {
                    contents: [{
                        parts: [
                            { text: prompt },
                            { inline_data: { mime_type: "image/jpeg", data: imageData } }
                        ]
                    }]
                };

                const response = await fetch(this.geminiUrl + '?key=' + this.apiKey, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                const data = await response.json();
                const text = data.candidates[0].content.parts[0].text;
                
                console.log("🧠 Gemini response:", text);
                
                if (text.includes('NO_MTG_CARD')) {
                    return { hasCard: false, message: "No MTG card detected" };
                }

                return this.parseResponse(text);
            }

            parseResponse(text) {
                try {
                    const nameMatch = text.match(/CARD_NAME:\s*([^|]+?)(?:\s*\||$)/i);
                    const setMatch = text.match(/SET_CODE:\s*([^|]+?)(?:\s*\||$)/i);
                    const collectorMatch = text.match(/COLLECTOR_NUM:\s*([^|]+?)(?:\s*\||$)/i);
                    const rarityMatch = text.match(/RARITY:\s*([^|]+?)(?:\s*\||$)/i);
                    const artistMatch = text.match(/ARTIST:\s*([^|]+?)(?:\s*\||$)/i);
                    const confidenceMatch = text.match(/CONFIDENCE:\s*(\d+)/i);

                    if (nameMatch) {
                        const result = {
                            hasCard: true,
                            name: nameMatch[1].trim(),
                            setCode: setMatch ? setMatch[1].trim() : null,
                            collectorNum: collectorMatch ? collectorMatch[1].trim().split('/')[0] : null,
                            rarity: rarityMatch ? rarityMatch[1].trim().toLowerCase() : null,
                            artist: artistMatch ? artistMatch[1].trim() : null,
                            confidence: parseInt(confidenceMatch?.[1] || '85'),
                            source: 'multi_mode_gemini'
                        };
                        
                        console.log("📝 Parsed result:", result);
                        return result;
                    }

                    return { hasCard: false, message: "Could not parse response" };
                } catch (error) {
                    console.error("❌ Parsing error:", error);
                    return { hasCard: false, message: "Parsing failed" };
                }
            }

            captureFrame(video) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = video.videoWidth || 640;
                canvas.height = video.videoHeight || 480;
                ctx.drawImage(video, 0, 0);
                return canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
            }

            getFallback() {
                return {
                    hasCard: true,
                    name: "Test Card",
                    confidence: 85,
                    source: 'fallback',
                    isFallback: true,
                    scanMode: this.scanMode
                };
            }
        }

        // AI DECKBUILDER SYSTEM
        class AIDeckbuilder {
            constructor() {
                this.currentFormat = 'commander';
                this.formatRules = {
                    commander: {
                        deckSize: 100,
                        singleton: true,
                        bannedCards: ['Black Lotus', 'Ancestral Recall'],
                        meta: ['Sol Ring', 'Command Tower', 'Arcane Signet']
                    },
                    standard: {
                        deckSize: 60,
                        singleton: false,
                        bannedCards: [],
                        meta: ['Fable of the Mirror-Breaker', 'Sheoldred, the Apocalypse']
                    },
                    modern: {
                        deckSize: 60,
                        singleton: false,
                        bannedCards: ['Oko, Thief of Crowns'],
                        meta: ['Lightning Bolt', 'Thoughtseize']
                    },
                    pioneer: {
                        deckSize: 60,
                        singleton: false,
                        bannedCards: [],
                        meta: ['Nykthos, Shrine to Nyx', 'Treasure Cruise']
                    },
                    legacy: {
                        deckSize: 60,
                        singleton: false,
                        bannedCards: ['Black Lotus'],
                        meta: ['Force of Will', 'Brainstorm']
                    }
                };
            }

            setFormat(format) {
                this.currentFormat = format;
                console.log(`🏗️ Deckbuilder format set to: ${format}`);
                this.updateAISuggestions();
            }

            updateAISuggestions() {
                const suggestions = this.generateSuggestions();
                const container = document.getElementById('aiSuggestions');
                
                container.innerHTML = suggestions.map(suggestion => `
                    <div class="suggestion-card">
                        <div class="suggestion-title">${suggestion.title}</div>
                        <div class="suggestion-desc">${suggestion.description}</div>
                        <div class="suggestion-cards">${suggestion.cards}</div>
                    </div>
                `).join('');
            }

            generateSuggestions() {
                const format = this.formatRules[this.currentFormat];
                const suggestions = [];

                switch(this.currentFormat) {
                    case 'commander':
                        suggestions.push({
                            title: "👑 Commander Staples",
                            description: "Essential cards for any Commander deck",
                            cards: "Sol Ring, Command Tower, Arcane Signet, Cultivate"
                        });
                        suggestions.push({
                            title: "💰 Ramp Package", 
                            description: "Accelerate your mana development",
                            cards: "Kodama's Reach, Rampant Growth, Explosive Vegetation"
                        });
                        suggestions.push({
                            title: "🎯 Card Draw Engine",
                            description: "Maintain card advantage throughout the game",
                            cards: "Rhystic Study, Mystic Remora, Phyrexian Arena"
                        });
                        break;
                    case 'standard':
                        suggestions.push({
                            title: "🎯 Current Standard Meta",
                            description: "Top tier cards dominating the format",
                            cards: "Fable of the Mirror-Breaker, Sheoldred, the Apocalypse"
                        });
                        suggestions.push({
                            title: "💪 Aggro Package",
                            description: "Fast, aggressive creatures and spells",
                            cards: "Monastery Swiftspear, Lightning Strike, Goblin Guide"
                        });
                        break;
                    case 'modern':
                        suggestions.push({
                            title: "⚡ Modern Staples",
                            description: "Format-defining cards for competitive play",
                            cards: "Lightning Bolt, Thoughtseize, Path to Exile"
                        });
                        suggestions.push({
                            title: "🏗️ Manabase",
                            description: "Consistent land base for competitive decks",
                            cards: "Fetch lands, Shock lands, Horizon lands"
                        });
                        break;
                    case 'pioneer':
                        suggestions.push({
                            title: "🚀 Pioneer Powerhouses", 
                            description: "High-impact cards for Pioneer format",
                            cards: "Nykthos, Shrine to Nyx, Treasure Cruise"
                        });
                        break;
                    case 'legacy':
                        suggestions.push({
                            title: "🏛️ Legacy Power",
                            description: "Eternal format staples and powerhouses",
                            cards: "Force of Will, Brainstorm, Wasteland"
                        });
                        break;
                }

                return suggestions;
            }

            analyzeCollection(collection) {
                // AI analysis of user's collection for deck suggestions
                console.log(`🤖 Analyzing collection for ${this.currentFormat} format...`);
                
                const analysis = {
                    formatLegal: collection.filter(card => this.isFormatLegal(card)),
                    missingStaples: this.getMissingStaples(collection),
                    deckSuggestions: this.getDeckSuggestions(collection)
                };
                
                return analysis;
            }

            isFormatLegal(card) {
                // Check if card is legal in current format
                const bannedCards = this.formatRules[this.currentFormat].bannedCards;
                return !bannedCards.includes(card.name);
            }

            getMissingStaples(collection) {
                const staples = this.formatRules[this.currentFormat].meta;
                const owned = collection.map(card => card.name);
                return staples.filter(staple => !owned.includes(staple));
            }

            getDeckSuggestions(collection) {
                // AI-powered deck archetype suggestions based on collection
                return [
                    {
                        archetype: "Aggro",
                        confidence: 85,
                        reason: "Strong creature base detected"
                    },
                    {
                        archetype: "Control", 
                        confidence: 70,
                        reason: "Counter spells and removal present"
                    }
                ];
            }
        }

        // GLOBAL VARIABLES
        let currentCard = null;
        let pendingEditionSelection = null;
        let collections = { 
            main: [], 
            premium: [], 
            commander: [],
            standard: [],
            modern: [],
            decks: [],
            wishlist: []
        };
        let activeBinder = 'main';
        let autoMode = false;
        let autoInterval = null;
        let userTier = localStorage.getItem('mtg_user_tier') || 'free';
        let userPlan = localStorage.getItem('mtg_plan_type') || 'free';
        let aiService = new MultiModeMTGService();
        let deckbuilder = new AIDeckbuilder();
        
        // Check for alpha access on load
        const alphaCode = localStorage.getItem('mtg_alpha_code');
        const alphaExpires = localStorage.getItem('mtg_alpha_expires');
        if (alphaCode && alphaExpires) {
            const now = new Date();
            const expires = new Date(alphaExpires);
            if (now <= expires) {
                document.getElementById('alphaCode').value = '✅ Alpha Active: ' + alphaCode;
                document.getElementById('alphaCode').style.background = '#28a745';
                document.getElementById('alphaCode').disabled = true;
                console.log('✅ Alpha access restored:', alphaCode);
            } else {
                localStorage.removeItem('mtg_alpha_code');
                localStorage.removeItem('mtg_alpha_expires');
                localStorage.setItem('mtg_user_tier', 'free');
                userTier = 'free';
            }
        }
        
        // LOADING SEQUENCE
        function runLoadingSequence() {
            setTimeout(() => {
                const loadingScreen = document.getElementById('loadingScreen');
                const mainApp = document.getElementById('mainApp');
                
                loadingScreen.classList.add('fade-out');
                mainApp.classList.add('loaded');
                
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 1000);
            }, 3500); // Longer loading for v3.0
        }

        // USAGE TRACKING
        function getTodayUsage() {
            const today = new Date().toDateString();
            return parseInt(localStorage.getItem('mtg_scans_' + today) || '0');
        }
        
        function updateUsageDisplay() {
            const usage = getTodayUsage();
            const planDetails = {
                'free': { limit: 20, name: 'Free', color: '#6c757d' },
                'basic': { limit: 1000, name: 'Basic', color: '#4a90e2' },
                'pro': { limit: 10000, name: 'Pro', color: '#6f42c1' },
                'family': { limit: 10000, name: 'Family', color: '#fd7e14' },
                'store': { limit: 999999, name: 'Store', color: '#28a745' }
            };
            
            const plan = planDetails[userPlan] || planDetails[userTier] || planDetails['free'];
            const limit = plan.limit;
            const percentage = (usage / limit) * 100;
            
            document.getElementById('usageCount').textContent = usage;
            document.getElementById('usageLimit').textContent = limit;
            document.getElementById('remainingCount').textContent = Math.max(0, limit - usage);
            document.getElementById('usageBar').style.width = Math.min(percentage, 100) + '%';
            document.getElementById('userTierDisplay').textContent = plan.name;
            
            const upgradeBtn = document.getElementById('upgradeBtn');
            if (userTier === 'premium') {
                upgradeBtn.textContent = `💎 ${plan.name} Plan Active`;
                upgradeBtn.style.background = plan.color || '#28a745';
                upgradeBtn.style.cursor = 'default';
                upgradeBtn.onclick = null;
            } else {
                upgradeBtn.textContent = '💎 Upgrade - Starting $4.99';
                upgradeBtn.style.background = '#4a90e2';
                upgradeBtn.style.cursor = 'pointer';
                upgradeBtn.onclick = () => alert('Upgrade modal would open here!');
            }
            
            if (usage >= limit && userTier === 'free') {
                document.getElementById('usageBar').style.background = '#ff6b6b';
                return false;
            }
            return true;
        }
        
        function trackScan() {
            if (userTier === 'premium') {
                return true;
            }
            
            if (!updateUsageDisplay()) {
                alert('Daily limit reached! Use alpha code ALPHA2024MTG for unlimited scans.');
                return false;
            }
            
            const today = new Date().toDateString();
            const currentUsage = getTodayUsage();
            localStorage.setItem('mtg_scans_' + today, (currentUsage + 1).toString());
            updateUsageDisplay();
            return true;
        }

        // SCAN MODE MANAGEMENT
        function setScanMode(mode) {
            // Update UI
            document.querySelectorAll('.scan-mode').forEach(el => el.classList.remove('active'));
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
            
            // Update service
            aiService.setScanMode(mode);
            
            // Update scan button text
            const btn = document.getElementById('scanBtn');
            const modeIcons = { fast: '⚡', accurate: '🎯', manual: '✋' };
            const modeNames = { fast: 'Fast', accurate: 'Accurate', manual: 'Manual' };
            btn.textContent = `${modeIcons[mode]} ${modeNames[mode]} Scan`;
            
            console.log(`🎯 Scan mode changed to: ${mode}`);
        }

        // CAMERA SETUP
        async function initCamera() {
            try {
                console.log("📷 Setting up multi-mode camera...");
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 1280 }, 
                        height: { ideal: 720 },
                        facingMode: 'environment' 
                    }
                });
                
                const video = document.getElementById('video');
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    document.getElementById('cameraStatus').style.display = 'none';
                    document.getElementById('scanBtn').disabled = false;
                    console.log("✅ Multi-mode camera ready");
                };
                
            } catch (error) {
                console.error("❌ Camera error:", error);
                document.getElementById('cameraStatus').innerHTML = "❌ Camera error<br><small>Please allow camera access</small>";
            }
        }

        // MULTI-MODE SCANNING FUNCTION
        async function scanCard() {
            if (!trackScan()) return;
            
            const btn = document.getElementById('scanBtn');
            btn.disabled = true;
            
            const mode = aiService.scanMode;
            const modeTexts = {
                fast: '⚡ Fast Scanning...',
                accurate: '🎯 Accurate Scanning...',
                manual: '✋ Manual Scanning...'
            };
            btn.textContent = modeTexts[mode];
            
            try {
                const video = document.getElementById('video');
                const result = await aiService.scanCard(video);
                
                if (result.hasCard) {
                    if (result.needsEditionPicker) {
                        displayEditionPicker(result);
                    } else {
                        displayResult(result);
                    }
                    console.log(`✅ ${mode} scan:`, result.name, `(${result.confidence}%)`);
                } else {
                    document.getElementById('results').innerHTML = 
                        '<div class="placeholder">❌ No MTG card detected<br><small>Try different angle or lighting</small></div>';
                }
                
            } catch (error) {
                console.error("❌ Scan error:", error);
                document.getElementById('results').innerHTML = 
                    '<div class="placeholder" style="color: #ff6b6b;">⚠️ Scanning error</div>';
            }
            
            btn.disabled = false;
            setScanMode(mode); // Reset button text
        }

        function displayEditionPicker(result) {
            pendingEditionSelection = result;
            
            const editionOptions = result.allPrintings ? 
                result.allPrintings.map(printing => `
                    <div class="edition-option" onclick="selectEdition('${printing.id}')">
                        <div class="edition-name">${printing.set_name}</div>
                        <div class="edition-details">${printing.set.toUpperCase()} #${printing.collector_number} • $${printing.prices.usd || 'N/A'}</div>
                    </div>
                `).join('') :
                '<div style="color: #888;">No editions found</div>';
            
            document.getElementById('results').innerHTML = `
                <div class="result-card">
                    <h4>${result.name}</h4>
                    <div class="confidence">Confidence: ${result.confidence}%</div>
                    <div style="color: #ffc107; font-size: 12px; margin: 10px 0;">🎯 Manual Mode: Select Edition</div>
                    
                    <div class="edition-selector">
                        <h5 style="color: #ffc107; margin-bottom: 10px;">Choose Edition:</h5>
                        <div class="edition-options">
                            ${editionOptions}
                        </div>
                    </div>
                </div>
            `;
        }

        function selectEdition(scryfallId) {
            if (!pendingEditionSelection) return;
            
            const selectedPrinting = pendingEditionSelection.allPrintings.find(p => p.id === scryfallId);
            if (selectedPrinting) {
                pendingEditionSelection.cardData = aiService.formatCardData(selectedPrinting, 'manual_selected');
                displayResult(pendingEditionSelection);
                pendingEditionSelection = null;
            }
        }

        function displayResult(card) {
            currentCard = card;
            
            const cardData = card.cardData;
            let priceDisplay = '';
            
            if (cardData) {
                if (cardData.price && cardData.price !== 'Price unavailable') {
                    priceDisplay = `<div style="color: #4a90e2; font-weight: bold; margin: 10px 0;">💰 $${cardData.price}</div>`;
                } else {
                    priceDisplay = '<div style="color: #ffc107; font-size: 12px; margin: 10px 0;">⚠️ Price temporarily unavailable</div>';
                }
            }
            
            const modeDisplay = `
                <div style="background: rgba(74, 144, 226, 0.1); border: 1px solid rgba(74, 144, 226, 0.3); border-radius: 6px; padding: 8px; margin: 10px 0; font-size: 12px;">
                    🎯 ${card.scanMode?.charAt(0).toUpperCase() + card.scanMode?.slice(1)} Mode: ${card.editionNote || 'Complete'}
                </div>
            `;
            
            const sourceInfo = card.isFallback ? 
                '<div style="color: #ffc107; font-size: 11px;">⚠️ Using fallback</div>' : 
                `<div style="color: #28a745; font-size: 11px;">✅ Multi-Mode Detection (${card.source})</div>`;
            
            document.getElementById('results').innerHTML = 
                '<div class="result-card">' +
                '<h4>' + card.name + '</h4>' +
                '<div class="confidence">Confidence: ' + card.confidence + '%</div>' +
                sourceInfo +
                modeDisplay +
                priceDisplay +
                (cardData && cardData.set ? '<div style="color: #888; font-size: 12px; margin: 10px 0;">Set: ' + cardData.set + '</div>' : '') +
                '<button onclick="saveToCollection()" class="btn" style="background: #28a745; color: white; margin: 10px 5px;">💾 Save to Collection</button>' +
                '<button onclick="addToDeck()" class="btn" style="background: #6f42c1; color: white; margin: 10px 5px;">🏗️ Add to Deck</button>' +
                (cardData && cardData.scryfallUri ? 
                    `<button onclick="window.open('${cardData.scryfallUri}', '_blank')" class="btn" style="background: #4a90e2; color: white; margin: 10px 5px;">🔗 Scryfall</button>` : '') +
                '</div>';
        }

        function saveToCollection() {
            if (!currentCard) return;
            
            const cardWithId = {
                name: currentCard.name,
                confidence: currentCard.confidence,
                source: currentCard.source,
                scanMode: currentCard.scanMode,
                cardData: currentCard.cardData,
                id: Date.now(),
                savedAt: new Date().toISOString()
            };
            
            collections[activeBinder].unshift(cardWithId);
            localStorage.setItem('mtg_collections', JSON.stringify(collections));
            
            console.log("✅ Card saved:", cardWithId);
            updateBinderDisplay();
            
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = "✅ Saved!";
            setTimeout(() => btn.textContent = originalText, 2000);
        }

        function addToDeck() {
            if (!currentCard) return;
            
            const format = deckbuilder.currentFormat;
            const deckName = `${format}_deck_${Date.now()}`;
            
            // Add to format-specific collection
            const formatCollection = collections[format] || [];
            formatCollection.unshift({
                ...currentCard,
                id: Date.now(),
                addedToDeck: deckName,
                savedAt: new Date().toISOString()
            });
            collections[format] = formatCollection;
            
            localStorage.setItem('mtg_collections', JSON.stringify(collections));
            updateBinderDisplay();
            
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = "✅ Added to Deck!";
            setTimeout(() => btn.textContent = originalText, 2000);
            
            console.log(`🏗️ Card added to ${format} deck:`, currentCard.name);
        }

        // AI DECKBUILDER FUNCTIONS
        function buildDeck() {
            const format = deckbuilder.currentFormat;
            const formatCards = collections[format] || [];
            
            if (formatCards.length === 0) {
                alert(`No cards in your ${format} collection yet! Start scanning cards to build a deck.`);
                return;
            }
            
            const analysis = deckbuilder.analyzeCollection(formatCards);
            
            alert(`🏗️ AI Deck Analysis (${format.toUpperCase()}):\n\n` +
                  `Format Legal Cards: ${analysis.formatLegal.length}\n` +
                  `Missing Staples: ${analysis.missingStaples.join(', ') || 'None'}\n` +
                  `Suggested Archetypes: ${analysis.deckSuggestions.map(s => s.archetype).join(', ')}\n\n` +
                  `Building optimal deck...`);
            
            console.log('🏗️ Building deck for format:', format, analysis);
        }

        function optimizeDeck() {
            const format = deckbuilder.currentFormat;
            alert(`⚡ Optimizing your ${format} deck with AI suggestions!\n\n` +
                  `• Analyzing mana curve\n` +
                  `• Checking format legality\n` +
                  `• Suggesting improvements\n` +
                  `• Calculating win rates\n\n` +
                  `Optimization complete!`);
            
            console.log('⚡ Optimizing deck for format:', format);
        }

        // COLLECTION MANAGEMENT
        function switchBinder(binderName) {
            activeBinder = binderName;
            
            document.querySelectorAll('.binder-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            const activeTab = document.querySelector(`[data-binder="${binderName}"]`);
            if (activeTab) {
                activeTab.classList.add('active');
            }
            
            updateBinderDisplay();
            console.log(`📚 Switched to binder: ${binderName}`);
        }

        function updateBinderDisplay() {
            const binder = collections[activeBinder] || [];
            const container = document.getElementById('binderCards');
            
            if (binder.length === 0) {
                const messages = {
                    main: 'No cards in main collection yet. Start scanning to build your collection!',
                    decks: 'No deck cards yet. Use "Add to Deck" to build format-specific decks!',
                    commander: 'No Commander cards yet. Scan cards and add them to build your 100-card deck!',
                    standard: 'No Standard cards yet. Build competitive 60-card decks!',
                    modern: 'No Modern cards yet. Collect powerful eternal format cards!'
                };
                
                container.innerHTML = 
                    '<div style="text-align: center; color: #888; padding: 40px;">' +
                    (messages[activeBinder] || `No cards in ${activeBinder} collection yet.`) +
                    '</div>';
            } else {
                container.innerHTML = binder.map(card => 
                    `<div class="collection-card">
                        <div class="card-name">${card.name}</div>
                        <div class="card-details">
                            <div>Confidence: ${card.confidence}%</div>
                            <div>Mode: ${card.scanMode || 'Unknown'}</div>
                            <div>Added: ${new Date(card.savedAt).toLocaleDateString()}</div>
                            ${card.cardData && card.cardData.set ? `<div>Set: ${card.cardData.set}</div>` : ''}
                            ${card.addedToDeck ? `<div>Deck: ${card.addedToDeck}</div>` : ''}
                        </div>
                        ${card.cardData && card.cardData.price ? 
                            `<div class="card-price">$${card.cardData.price}</div>` :
                            '<div style="background: #666; color: white; padding: 4px 8px; border-radius: 6px; font-size: 12px; display: inline-block;">Price Loading...</div>'
                        }
                    </div>`
                ).join('');
            }
            
            updateBinderStats();
        }

        function updateBinderStats() {
            const allCards = Object.values(collections).flat();
            const uniqueCards = [...new Set(allCards.map(card => card.name))];
            const decks = collections.decks || [];
            
            let totalValue = 0;
            let priceCount = 0;
            
            allCards.forEach(card => {
                if (card.cardData && card.cardData.price) {
                    const price = parseFloat(card.cardData.price);
                    if (!isNaN(price)) {
                        totalValue += price;
                        priceCount++;
                    }
                }
            });
            
            document.getElementById('totalCards').textContent = allCards.length;
            document.getElementById('uniqueCards').textContent = uniqueCards.length;
            document.getElementById('totalValue').textContent = priceCount > 0 ? 
                '$' + totalValue.toFixed(2) : '$0.00';
            document.getElementById('deckCount').textContent = Math.floor(decks.length / 60); // Estimate complete decks
        }

        // AUTO MODE
        function toggleAutoMode() {
            autoMode = !autoMode;
            const btn = document.getElementById('autoBtn');
            
            if (autoMode) {
                btn.textContent = "⏹️ Stop";
                btn.style.background = "#dc3545";
                
                autoInterval = setInterval(() => {
                    if (!document.getElementById('scanBtn').disabled) {
                        scanCard();
                    }
                }, 5000); // Slower for multi-mode
                
                console.log("▶️ Multi-mode auto scanning started");
            } else {
                btn.textContent = "▶️ Auto";
                btn.style.background = "#28a745";
                
                if (autoInterval) {
                    clearInterval(autoInterval);
                    autoInterval = null;
                }
                
                console.log("⏹️ Multi-mode auto scanning stopped");
            }
        }

        // EVENT LISTENERS & INITIALIZATION
        window.addEventListener('load', async function() {
            console.log("🚀 Initializing MTG Scanner Pro v3.0...");
            
            // Load saved collections
            const savedCollections = localStorage.getItem('mtg_collections');
            if (savedCollections) {
                try {
                    const loaded = JSON.parse(savedCollections);
                    collections = {
                        main: loaded.main || [],
                        premium: loaded.premium || [],
                        commander: loaded.commander || [],
                        standard: loaded.standard || [],
                        modern: loaded.modern || [],
                        decks: loaded.decks || [],
                        wishlist: loaded.wishlist || []
                    };
                } catch (e) {
                    console.log("❌ Error loading collections:", e);
                }
            }
            
            // Set up event listeners
            document.getElementById('scanBtn').addEventListener('click', scanCard);
            document.getElementById('autoBtn').addEventListener('click', toggleAutoMode);
            
            // Scan mode selector
            document.querySelectorAll('.scan-mode').forEach(mode => {
                mode.addEventListener('click', function() {
                    setScanMode(this.dataset.mode);
                });
            });
            
            // Format selector
            document.querySelectorAll('.format-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    document.querySelectorAll('.format-tab').forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    deckbuilder.setFormat(this.dataset.format);
                });
            });
            
            // Binder tabs
            document.querySelectorAll('.binder-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    switchBinder(this.dataset.binder);
                });
            });
            
            // Start loading sequence
            runLoadingSequence();
            
            // Initialize displays
            updateUsageDisplay();
            updateBinderDisplay();
            deckbuilder.updateAISuggestions();
            
            await initCamera();
            
            console.log("✅ MTG Scanner Pro v3.0 ready!");
            console.log("🔧 v3.0 Features:");
            console.log("  - ✅ Multi-Mode Scanning: Fast/Accurate/Manual");
            console.log("  - ✅ AI Deckbuilder: Format-specific intelligence");
            console.log("  - ✅ Format Collections: Commander, Standard, Modern, etc.");
            console.log("  - ✅ Edition Selection: Manual picker for accuracy");
            console.log("  - ✅ Deck Analysis: Meta suggestions and optimization");
            console.log("📊 User Status:");
            console.log("  - Tier:", userTier);
            console.log("  - Plan:", userPlan);
            console.log("  - Current Format:", deckbuilder.currentFormat);
            
            window.mtgV3 = {
                version: '3.0',
                features: ['multi_mode_scanning', 'ai_deckbuilder', 'format_collections'],
                setScanMode: setScanMode,
                setFormat: (format) => deckbuilder.setFormat(format),
                testAlpha: (code) => {
                    document.getElementById('alphaCode').value = code;
                    checkAlphaCode();
                }
            };
        });

        // Make functions global
        window.saveToCollection = saveToCollection;
        window.addToDeck = addToDeck;
        window.buildDeck = buildDeck;
        window.optimizeDeck = optimizeDeck;
        window.selectEdition = selectEdition;
        window.checkAlphaCode = checkAlphaCode;

        // Cleanup
        window.addEventListener('beforeunload', function() {
            if (autoInterval) clearInterval(autoInterval);
            const video = document.getElementById('video');
            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>